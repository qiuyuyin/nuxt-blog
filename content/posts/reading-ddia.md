---
title: DDIA导读
date: 2022-05-02 15:55:33
categories: 
 - 系统设计
tags: 
 - books
 - system

---

## DDIA 导读

最近很多大佬都在推荐DDIA这本书，所以笔者也是抽出时间拜读了这本2018出版的紧跟时代的应用型神书，用于构建一套自己的体系思维，同时在读的同时记下书籍的一些要点并总结一些自己的思想和观点。

### 第一章

#### 数据系统特性

第一章主要对数据系统的特性进行了介绍，主要是可靠性、可拓展性、可维护性。

可靠性：容忍硬件软件错误

可拓展性：负载性能、延迟系数

可维护性：可运维、可不断演化



现在的互联网应用一般都是数据密集型应用，而非计算密集型应用，大多数操作耗时于网络的连接和通信上，这个时候就需要维持多线程来保证可以在同一时间处理成千上万的连接。

### 第二章

#### 数据模型

第二章主要对数据模型进行了介绍，主要存在的数据模型为关系模型、文档模型、图状数据模型。

关系数据模型就是诸如PostgreSql 、Mysql 等关系型数据库所进行构建的模型

而文档模型便是类似使用Json格式所构建的数据库模型，较为常用的数据库为MongoDB

图状数据模型是为了解决更为复杂的模型所构建的一种数据库模型，比如在搜索引擎中所使用的PageRank以及在导航系统的计算算法，都是需要依赖于图类模型来进行存储。



Neo4j是一个比较常用的图状数据库模型，其可存储PB级别的数据，可为AL和ML定制应用管道，来解决更为复杂的系统算法问题。

Graph数据库主要就是为了简化不同字段之间的多对多关系而设计应用的一款数据库，比如在一个复杂的多对多查询中，需要设计多个join才可以查询到所需要的数据，但是使用Cypher来进行查询一般只需要一行便可完成。

下面是cypher和sql来进行查询的对比：

```cypher
MATCH (p:Product)-[:CATEGORY]->(l:ProductCategory)-[:PARENT*0..]->(:ProductCategory {name:"Dairy Products"})
RETURN p.name
```

```sql
SELECT p.ProductName
FROM Product AS p
JOIN ProductCategory pc ON (p.CategoryID = pc.CategoryID AND pc.CategoryName = "Dairy Products")

JOIN ProductCategory pc1 ON (p.CategoryID = pc1.CategoryID)
JOIN ProductCategory pc2 ON (pc1.ParentID = pc2.CategoryID AND pc2.CategoryName = "Dairy Products")

JOIN ProductCategory pc3 ON (p.CategoryID = pc3.CategoryID)
JOIN ProductCategory pc4 ON (pc3.ParentID = pc4.CategoryID)
JOIN ProductCategory pc5 ON (pc4.ParentID = pc5.CategoryID AND pc5.CategoryName = "Dairy Products");
```

可以看出来cypher就是一种为多对多关系而生的一种查询方式。

综上所述，不同种类的数据是专门用于其特定所需要处理的场所，正所谓术业有专攻，在不同的场景下使用合适的存储系统才是应该想要的。

### 第三章

#### 数据存储与检索

其实本章的内容是任何一本数据库书籍都会涉及到的，比如

不仅存储系统的类型存在差异，同时存储系统的构造也是存在很大的差异的，在一般的数据库场景分析中，一般会对行式存储和列式存储进行对比。

OLTP（Online Transaction Processing 在线事务处理）在现代服务系统中，总是需要对各种数据进行读取，比如视频的评论，网页个人的详细信息，通讯录中的联系人等，都是使用索引中的某些键来查找全部信息。这些都是和用户端需要实时查询的信息。

但是在现在的系统中，数据库也越来常见用于数据的分析，比如在各个APP的年度报告中，需要提前将用户的所有信息进行查询和分析来得到最后的结果，这个时候并不需要进行实时处理，而是尽量做到大量数据的分析和处理，一般都是提供给公司内部来进行分析，或者提供给公司的合作方（比如电商中的店铺、外卖服务的商家、短视频服务的创作者）以便于根据现在的情况来做出不同的改变，比如将某件不合适的商品下架或者降价，改变视频的风格或者减少视频中广告等。这些都是建立在对大量数据的分析，同时不需要追求实时性（延时数分钟并没有任何问题），这便是OLAP（Online Analytic Processing 在线分析处理系统）

在数据量较小，业务需求较小的时代，使用关系型数据库既可以完成事务处理和分析查询，但是在数据量不断扩大以及产品类型不断繁杂中，绝大多数的公司弃用关系型数据库来完成OLAP 而是使用数据仓库的形式来完成。

#### 为何演进

像一般的关系型数据库一般使用的是行式存储，了解过 Mysql 的行级锁的同学一般都知道，在事务的进行中，行级别的锁起到很关键的作用，虽然可以使用页级别的锁，但是在性能要求较高的数据库中一般使用的都是行级别的锁。

而如果需要对大量数据进行分析的时候，比如分布式数据库、数据仓库等，使用行级别的数据库会很快就会力不从心，因为使用行级别的数据库需要花大量的时间构建索引，想象一下Mysql建立索引的过程，会将所有的索引都存储在索引页中，查询性能和构建性能都会大大降低。在此等情况下，基于分布式系统的成型，HBase等分布式列式存储数据库也慢慢的发展起来。

### 第四章

#### 数据编码与演化

在程序中一般存在两种不同的数据编码方式

- 计算结构：在对程序的应用中，不免需要考虑和使用 树、哈希、数组、结构体等结构来抽象化，以致于程序完整的运行。
- 传输结构：在网络层来对数据进行传输，比如TCP和UDP有其特殊的结构，在HTTP层进行传输可以使用JSON格式来对发送的请求进行编解码，同时在grpc中会使用Protobuf的格式来进行编解码。

#### 编码格式

在现代服务器系统中，比较常见的编码格式便是Json、XML、csv等格式。这种格式可以被工程师们正确的进行解析，但是由于其多余的字段用于标注其格式，所以其在传输过程和解析过程中需要耗费相对于直接的二进制格式更多的时间，最为人称道的是JSON格式对于浮点数的不支持。所以一般在服务器之间的交互中，一般使用二进制格式来使用和交互。

二进制编码最大的一个优化便是在传输的时候是不需要明白每个字段的字段名的，比如：

在下面的一个json串中，字段名是需要同时传输过去的

```json
{
	"username":"yili",
    "password":"*****"
}
```

在protobuf中，只需要按照字段的位置传输即可

```protobuf
{
  required string username = 1;
  required string password = 2;
}
```

但是使用protobuf存在一个缺点，就是需要在调用端维护一个protobuf文件来表示每个字段的名称，也就是客户端在调用的时候是按照保存在本地的protobuf来进行调用的。这对传统的CS架构是不可能完成的，客户端是不可能保存一套代码的，除非你特地在客户端保存一份protobuf来解析这个字段，但是由于兼容性等缘故这样的实现其实是很困难的。所以在南北数据交换中一般都是使用json来作为数据字段的解析的。而在东西数据交流时使用二进制格式来进行操作。

#### 系统迭代

在系统的迭代过程中，让我们较为头疼的就是服务端和客户端的兼容性，比如拿B站为例，现在的服务端团队想要修改错误字段对应的含义来进行标准化，但是由于客户端版本的限制（由于一部分客户端版本是没有进行更新的）所以一旦修改交互的字段之后便会出现问题。

所以在设计一个系统时，一般都是从API接口接口开始实现的，比如一个API应该返回什么数据，如果这个数据缺省会造成什么样的情况，这些都是需要在设计一个产品时就需要考虑清楚的。比如QQ在早期协议的设计中就存在很多的问题，但是由于需要维护兼容性，系统只能设计的越来越复杂，之后的新员工在上手操作的时候需要很大的时间来进行适应，造成如果想要主推一个新功能需要耗费很大的人力物力。

#### 本章总结

本章所介绍的内容实际上是对现在的编程体系进行一些总结，将分散开来的知识总结到一起，形成一个知识体系，更好的了解现代的系统结构。

持续更新。。
