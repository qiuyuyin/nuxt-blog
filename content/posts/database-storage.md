---
title: 数据库|存储模型
date: 2022/3/24 20:57:00
updated: 2022/3/24 20:57:00
categories: 
 - 基础
tags: 
 - database 
 - 文件系统
---

## database-storage

### File Storage

现在一般的数据库系统一般存储在文件系统中，也就是传统的disk，虽然存在一些数据库为了最大化效率会将数据存储在内存中，比如redis，但是redis也是会进行持久化操作的。也就是说我们需要将数据库中的数据作为一个传统意义上的文件保存在操作系统上，但是这些二进制文件并不像txt一样可以被人类所识别，而是数据库内置了一个解析器来对文件系统进行解析。

 思来想去还是从一个表在文件系统中的存储来说比较易懂一些，国内的很多讲解都会扯一些假大空的概念让很多读者读完之后还是云里雾里，虽然我做不到将这些知识细致直观地展现出来，但是我尽力😏

你最想了解的肯定是数据库中的一个表在文件系统中的存储格式是怎样的，一般一个表的存储分为两个存储部分，分别是索引和数据段（其实是一段废话）。索引可以使用B或B+树的结构来进行存储，而数据段就像我们熟悉的excel表格一样进行存储，通过索引来查找数据段这是一个比较高效的方式，并且索引会在加载表的时候直接加载到内存中，这并没有可以在disk存储上面深究的地方。

所以先来了解数据段是如何在文件系统中存储的吧。

1.定长存储（Fixed-Length Records)

下面定义的一个十分简单的表格，我们可以认为每个表格占用的字符为1，那么这个表中没一行所占用的数据便是53byte

```sql
type instructor = record
	ID varchar (5);
	name varchar(20);
	dept name varchar (20);
	salary numeric (8,2);
end
```

所以这个表格在文件系统中的样子：

![image-20220321173624187](https://yili979.oss-cn-beijing.aliyuncs.com/img/202203211736544.png)

然而通过这种方式进行存储存在两个问题：

1.由于字段不可被文件的page大小进行整除，所以会导致某一行的数据会横跨两个block（数据库的存储也必须像操作系统一样进行分块操作，这是任何一个存储系统的必经之路），当然解决这个问题也十分的简单，只需要将每个block中的最后一段数据空出来即可。

2.如何在这个表格中进行删除操作？在数据库的系统中不可避免的需要将某一段数据进行删除操作，所以应该如何对数据进行删除操作呢，现在我们删除第5行字段，这一行便空出来了53个字节的空间，是将其后面的数据转移53个字节大小，然后占用这个空闲空间吗？这显然不是一个很好的手段。其实这是一个我们在使用高级编程语言中经常遇到的问题，就是内存碎片的清除，总有几个算法来进行解决，比如标记整理，标记复制等等。但是在持久文件中进行文件内容的移动其实不是一个很高效的操作，所以在一般的数据库存储中是不会通过这种方式来整理删除的文件的。

一种处理数据库删除碎片的方式是通过维护一个空闲链表（其实在操作系统中也有对应的文件分配结构），在文件头维护一个header指向下一个空闲块，下一次执行insert操作的时候直接遍历header寻找空闲块即可。

![image-20220321204324657](https://yili979.oss-cn-beijing.aliyuncs.com/img/202203212043572.png)

2.变长存储（Variable-Length Records）

在数据库中存在一些通过变长存储的数据类型，比如varchar（老朋友了，mysql中经常看见），可以通过变长的形式来存储字符串，而不是像定长的char在字符串结尾补0.总的来说变长字符串一定程度上会减少字符串空间的占用，但是在构建索引进行搜索的时候性能会比char更差一些。

那么数据库的文件是如何对varchar类型进行存储的呢？

```sql
type instructor = record
	ID varchar (5);
	name varchar(20);
	dept name varchar (20);
	salary numeric (8,2);
end
```

还是之前的结构体，这里维护了三个varchar类型的字符串和一个numeric类型。然后再这个表插入的第一行数据是

| 10001 | Srinivasan | Comp. Sci. | 65000 |
| ----- | ---------- | ---------- | ----- |

为了维护varchar类型，需要为varchar额外添加两个字段len和offset，分别表示varchar的长度和在行中的偏移量。如果还不理解，那么下面的图片你一看就会明白：

![image-20220321213840049](https://yili979.oss-cn-beijing.aliyuncs.com/img/202203212138756.png)

可以看见varchar多使用了4个字节分别表示长度和offset，两个字节的最大长度为65535,所以字符串的长度最大为65535，同时单个block的大小最大一定是不会超过64KB的。

在上图中还存在一个bitmap,这个是由于我们可以在定义表中来定义每个字段是否为空，当设置为 可以为空 时，其在初始化时便为null，在bitmap中这个字段便是1

3.大数据存储（Stroe Large Objects)

在很多的数据库中都会对数据字段的长度进行限制，比如变长字符串一般的长度最大都是65535（其实小于这个数字），也就是一个block的大小。但是在某种情况下，用户可能需要存储过大的数据，各个数据库同样提供了解决方案，比如在mysql中存储大于65535长度的字符串就需要使用text或者blob。

就像TCMalloc一样，在对大型的对象存储的时候一般是不会和小型对象存储在一起的，而是在其他的一个地方维护一个文件系统来对大型文件进行存储。

---

 当然上述对数据库的数据段的storage其实不是特别重要的，其一是构造方式和操作系统的文件系统存在很大的相似性，其二不同的数据库的文件分布存在较大差异并没有普适性。

在实际数据库系统中的查询操作一般都是存在限定性的，比如在一个表中查找name为李华的学生，这个时候如果遍历表结构其实是非常不划算的（在数据库中数据十分庞大时效率会十分低下）所以一般的关系型数据库中一般都会存在一个索引结构来通过特定的字段来寻找其在表中的内容。

### index

《Database System Concepts》书中花了很长的一段篇幅来讲顺序的索引结构。我不打算展开聊这一点，因为在我们认知中的数据库的索引结构其实大多都是通过B+树来进行构建的，所以花太多时间在顺序存储上其实是没有什么必要的。

由于顺序存储在查询和插入上的时间复杂度都是O(N)，所以当数据库中的数据成倍增长的时候查询的效率也会快速降低，所以引入新的数据结构来构建索引其实是一件势在必得的事情。

其实B+树的结构在本质上是一个多级索引结构，不过是做成了一种平衡树的形式，是B树的一种变种。B+树的节点结构如下图所示：

![image-20220322171556358](https://yili979.oss-cn-beijing.aliyuncs.com/img/202203221716220.png)

存在n个值和n个指针指向下一个节点，同时在节点中的值是按照顺序进行排布的。和B树不同，B+树仅在根节点保存数据，并且根节点的数据是通过一个双向链表进行连接的，由于B+树仅在根节点保存数据，所以其查询的时间复杂度为O(logN)

下面是一个表在B+树中保存的示意图：

![image-20220322231332382](https://yili979.oss-cn-beijing.aliyuncs.com/img/202203222313021.png)

有一件事情其实是我们都挺希望了解的，就是一个B+树在数据库中到底能保存多少数据？这里以Mysql的InnoDB引擎为例，在InnoDB中page的大小为16KB，所以在数据库中一个节点的大小一般都为16KB（当然不是绝对的），假设我们存储的value是一个bigint类型占用8个byte，同时在数据库中一个数据的指针一般为6Byte，所以一个数据字段占用的大小为14byte，所以在非叶子节点中最多保存的数据为16*1024/14 = 1170, 假设在叶子节点中一行数据字段大小为512byte，所以叶子节点中保存的行数为32。如果是一个深度为2的B+树则最多保存的行数为1170 * 32 = 37440，而一个深度为3的B+树最多保存43,804,800行。可以发现最多需要三行就可以保存千万量级的字段，这个实现的效果还是非常的令人满意的。

可能你会存在一个疑问就是为何B+树的深度如此的小呢，这样会不会导致在一个节点中进行线性查找的次数过多呢？其实不然，由于在数据库中一般数据都是保存在磁盘中的，当需要对数据进行处理的时候会讲数据加载到缓冲区中。所以在一般的数据库中一般仅仅将一些索引加载到内存中，想象一下如果B+树的高度为4，则可能会将上面三层的数据全部加载到内存中这是一个非常恐怖的数字，我们刚才已经进行了计算，1170  * 1170 *16KB 这是一个十分恐怖的量级，我们不会存在那么多的主存空间分配给数据索引，所以一般来说加载两层的索引是可以接受的，也就是1170 * 16KB = 18 MB 这是可以接受的一个数字。

所以在数据库中B+树的高度并不是越多越好。

> 这样来看一个Mysql表格中的行数最多是千万量级，如果业务量超过千万的量级时应该怎么办呢？现如今大多数互联网产品的用户数量一般都超过了千万，千万用户所产生的数据量甚至过亿过十亿，这个时候应该怎样解决这个问题呢？

在比较厉害的互联网公司一般都会招聘一些数据库专家对一些开源的数据库进行优化以达到大厂所需要的承载量，在一些比较有钱的银行或者国企会购买一些专用的商业数据库来保证存储的压力（比如Oracle和微软的数据库产品做的是非常优秀的，可以保证数十亿数据量的快速访问）

当然除了硬件方面的解决方案，同时也存在着一些在软件层面的优化，比如我就经常听见别人戏称抖音的表都是按天来分的，甚至可能是按小时来分的。其实这并不是没有道理，按照抖音日活十亿的恐怖数据来看，在高峰期甚至可能在数分钟就将表给填满（当然我也没有在字节上过班，都是一些妄加揣测，不要当真，有可能人家直接上NoSql了呢）

分库分表，一个熟悉的名词，在性能问题的解决方案中，要么就是将单个组件的性能增加到极致，要么就是通过增加数量太提升整体的性能，包括但不限于多核心CPU、分布式系统、大数据相关技术等等。所以在数据库中也存在这样的一种解决方案就是一个库不够就多来几个库。比如一些垂直分表、水平分表和Hash来处理主键，通过一些简单的方案就可以进行解决。

其实分库分表并不是一个银弹，因为业务总是在增长，表也一定会越来越多，在我看来这只是一种妥协的方式来对数据库的性能问题进行解决。有一种思想是我一直秉承的，就是当把一些上层的思想下放到底层来进行解决才是最好的，最近无意间浏览到一款国产的分布式数据库TiDB，通过分布式的方案来对数据库的性能进行解决，同时其上层兼容Mysql的连接，当然TiDB的解决方式也可能不是一款最佳方案，其投入与产出也可能不如分库分表来的方便，但是技术总是在不断前进不是吗，面对一个问题，总是会存在新的解决方案，所以作为软件工程师，切莫把自己定格在一些条条框框中，不然和机器有何区别呢，共勉。
